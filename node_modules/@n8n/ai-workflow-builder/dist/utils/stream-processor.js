"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_WORKFLOW_UPDATE_TOOLS = void 0;
exports.processStreamChunk = processStreamChunk;
exports.createStreamProcessor = createStreamProcessor;
exports.formatMessages = formatMessages;
const messages_1 = require("@langchain/core/messages");
exports.DEFAULT_WORKFLOW_UPDATE_TOOLS = [
    'add_nodes',
    'connect_nodes',
    'update_node_parameters',
    'remove_node',
];
function processStreamChunk(streamMode, chunk) {
    if (streamMode === 'updates') {
        const agentChunk = chunk;
        if ((agentChunk?.delete_messages?.messages ?? []).length > 0) {
            const messageChunk = {
                role: 'assistant',
                type: 'message',
                text: 'Deleted, refresh?',
            };
            return { messages: [messageChunk] };
        }
        if ((agentChunk?.compact_messages?.messages ?? []).length > 0) {
            const lastMessage = agentChunk.compact_messages.messages[agentChunk.compact_messages.messages.length - 1];
            const messageChunk = {
                role: 'assistant',
                type: 'message',
                text: lastMessage.content,
            };
            return { messages: [messageChunk] };
        }
        if ((agentChunk?.agent?.messages ?? []).length > 0) {
            const lastMessage = agentChunk.agent.messages[agentChunk.agent.messages.length - 1];
            if (lastMessage.content) {
                let content;
                if (Array.isArray(lastMessage.content)) {
                    content = lastMessage.content
                        .filter((c) => c.type === 'text')
                        .map((b) => b.text)
                        .join('\n');
                }
                else {
                    content = lastMessage.content;
                }
                const messageChunk = {
                    role: 'assistant',
                    type: 'message',
                    text: content,
                };
                return { messages: [messageChunk] };
            }
        }
        if (agentChunk?.process_operations) {
            const update = agentChunk.process_operations;
            if (update.workflowJSON && update.workflowOperations !== undefined) {
                const workflowUpdateChunk = {
                    role: 'assistant',
                    type: 'workflow-updated',
                    codeSnippet: JSON.stringify(update.workflowJSON, null, 2),
                };
                return { messages: [workflowUpdateChunk] };
            }
        }
    }
    else if (streamMode === 'custom') {
        const toolChunk = chunk;
        if (toolChunk?.type === 'tool') {
            const output = { messages: [toolChunk] };
            return output;
        }
    }
    return null;
}
async function* createStreamProcessor(stream) {
    for await (const [streamMode, chunk] of stream) {
        const output = processStreamChunk(streamMode, chunk);
        if (output) {
            yield output;
        }
    }
}
function formatMessages(messages) {
    const formattedMessages = [];
    for (const msg of messages) {
        if (msg instanceof messages_1.HumanMessage) {
            formattedMessages.push({
                role: 'user',
                type: 'message',
                text: msg.content,
            });
        }
        else if (msg instanceof messages_1.AIMessage) {
            if (msg.content) {
                if (Array.isArray(msg.content)) {
                    const textMessages = msg.content.filter((c) => c.type === 'text');
                    textMessages.forEach((textMessage) => {
                        if (textMessage.type !== 'text') {
                            return;
                        }
                        formattedMessages.push({
                            role: 'assistant',
                            type: 'message',
                            text: textMessage.text,
                        });
                    });
                }
                else {
                    formattedMessages.push({
                        role: 'assistant',
                        type: 'message',
                        text: msg.content,
                    });
                }
            }
            if (msg.tool_calls && msg.tool_calls.length > 0) {
                for (const toolCall of msg.tool_calls) {
                    formattedMessages.push({
                        id: toolCall.id,
                        toolCallId: toolCall.id,
                        role: 'assistant',
                        type: 'tool',
                        toolName: toolCall.name,
                        status: 'completed',
                        updates: [
                            {
                                type: 'input',
                                data: toolCall.args || {},
                            },
                        ],
                    });
                }
            }
        }
        else if (msg instanceof messages_1.ToolMessage) {
            const toolCallId = msg.tool_call_id;
            for (let i = formattedMessages.length - 1; i >= 0; i--) {
                const m = formattedMessages[i];
                if (m.type === 'tool' && m.id === toolCallId) {
                    m.updates ??= [];
                    m.updates.push({
                        type: 'output',
                        data: typeof msg.content === 'string' ? { result: msg.content } : msg.content,
                    });
                    break;
                }
            }
        }
    }
    return formattedMessages;
}
//# sourceMappingURL=stream-processor.js.map