"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toDslColumns = toDslColumns;
exports.addColumnQuery = addColumnQuery;
exports.deleteColumnQuery = deleteColumnQuery;
exports.splitRowsByExistence = splitRowsByExistence;
exports.quoteIdentifier = quoteIdentifier;
exports.extractReturningData = extractReturningData;
exports.extractInsertedIds = extractInsertedIds;
exports.normalizeRows = normalizeRows;
exports.normalizeValue = normalizeValue;
exports.getPlaceholder = getPlaceholder;
exports.buildColumnTypeMap = buildColumnTypeMap;
const api_types_1 = require("@n8n/api-types");
const db_1 = require("@n8n/db");
const n8n_workflow_1 = require("n8n-workflow");
const not_found_error_1 = require("../../../errors/response-errors/not-found.error");
function toDslColumns(columns) {
    return columns.map((col) => {
        const name = new db_1.DslColumn(col.name.trim());
        switch (col.type) {
            case 'number':
                return name.double;
            case 'boolean':
                return name.bool;
            case 'string':
                return name.text;
            case 'date':
                return name.timestampTimezone();
            default:
                return name.text;
        }
    });
}
function dataStoreColumnTypeToSql(type, dbType) {
    switch (type) {
        case 'string':
            return 'TEXT';
        case 'number':
            switch (dbType) {
                case 'postgres':
                    return 'DOUBLE PRECISION';
                case 'mysql':
                case 'mariadb':
                    return 'DOUBLE';
                case 'sqlite':
                    return 'REAL';
                default:
                    return 'DOUBLE';
            }
        case 'boolean':
            return 'BOOLEAN';
        case 'date':
            if (dbType === 'postgres') {
                return 'TIMESTAMP';
            }
            return 'DATETIME';
        default:
            throw new not_found_error_1.NotFoundError(`Unsupported field type: ${type}`);
    }
}
function columnToWildcardAndType(column, dbType) {
    return `${quoteIdentifier(column.name, dbType)} ${dataStoreColumnTypeToSql(column.type, dbType)}`;
}
function isValidColumnName(name) {
    return api_types_1.DATA_STORE_COLUMN_REGEX.test(name);
}
function addColumnQuery(tableName, column, dbType) {
    if (!isValidColumnName(column.name)) {
        throw new n8n_workflow_1.UnexpectedError('bad column name');
    }
    const quotedTableName = quoteIdentifier(tableName, dbType);
    return `ALTER TABLE ${quotedTableName} ADD ${columnToWildcardAndType(column, dbType)}`;
}
function deleteColumnQuery(tableName, column, dbType) {
    const quotedTableName = quoteIdentifier(tableName, dbType);
    return `ALTER TABLE ${quotedTableName} DROP COLUMN ${quoteIdentifier(column, dbType)}`;
}
function splitRowsByExistence(existing, matchFields, rows) {
    const getMatchKey = (row) => JSON.stringify(Object.fromEntries(matchFields.map((field) => [field, row[field]])));
    const existingSet = new Set(existing.map((row) => getMatchKey(row)));
    const rowsToUpdate = [];
    const rowsToInsert = [];
    for (const row of rows) {
        const key = getMatchKey(row);
        if (existingSet.has(key)) {
            rowsToUpdate.push(row);
        }
        else {
            rowsToInsert.push(row);
        }
    }
    return { rowsToInsert, rowsToUpdate };
}
function quoteIdentifier(name, dbType) {
    switch (dbType) {
        case 'mysql':
        case 'mariadb':
            return `\`${name}\``;
        case 'postgres':
        case 'sqlite':
        default:
            return `"${name}"`;
    }
}
const isArrayOf = (data, itemGuard) => Array.isArray(data) && data.every(itemGuard);
const isNumber = (value) => {
    return typeof value === 'number' && Number.isFinite(value);
};
function hasInsertId(data) {
    return typeof data === 'object' && data !== null && 'insertId' in data && isNumber(data.insertId);
}
function hasRowId(data) {
    return typeof data === 'object' && data !== null && 'id' in data && isNumber(data.id);
}
function extractReturningData(raw) {
    if (!isArrayOf(raw, hasRowId)) {
        throw new n8n_workflow_1.UnexpectedError('Expected INSERT INTO raw to be { id: number }[] on Postgres or MariaDB');
    }
    return raw;
}
function extractInsertedIds(raw, dbType) {
    switch (dbType) {
        case 'postgres':
        case 'mariadb': {
            if (!isArrayOf(raw, hasRowId)) {
                throw new n8n_workflow_1.UnexpectedError('Expected INSERT INTO raw to be { id: number }[] on Postgres or MariaDB');
            }
            return raw.map((r) => r.id);
        }
        case 'mysql': {
            if (!hasInsertId(raw)) {
                throw new n8n_workflow_1.UnexpectedError('Expected INSERT INTO raw.insertId: number for MySQL');
            }
            return [raw.insertId];
        }
        case 'sqlite':
        default: {
            if (!isNumber(raw)) {
                throw new n8n_workflow_1.UnexpectedError('Expected INSERT INTO raw to be a number for SQLite');
            }
            return [raw];
        }
    }
}
function normalizeRows(rows, columns) {
    const typeMap = new Map(columns.map((col) => [col.name, col.type]));
    return rows.map((row) => {
        const normalized = { ...row };
        for (const [key, value] of Object.entries(row)) {
            const type = typeMap.get(key);
            if (type === 'boolean') {
                if (typeof value === 'boolean') {
                    normalized[key] = value;
                }
                else if (value === 1 || value === '1') {
                    normalized[key] = true;
                }
                else if (value === 0 || value === '0') {
                    normalized[key] = false;
                }
            }
            if (type === 'date' && value !== null && value !== undefined) {
                let dateObj = null;
                if (value instanceof Date) {
                    dateObj = value;
                }
                else if (typeof value === 'string' || typeof value === 'number') {
                    const parsed = new Date(value);
                    if (!isNaN(parsed.getTime())) {
                        dateObj = parsed;
                    }
                }
                normalized[key] = dateObj ? dateObj.toISOString() : value;
            }
        }
        return normalized;
    });
}
function normalizeValue(value, columnType, dbType) {
    if (['mysql', 'mariadb'].includes(dbType)) {
        if (columnType === 'date') {
            if (value instanceof Date) {
                return value;
            }
            else if (typeof value === 'string') {
                const date = new Date(value);
                if (!isNaN(date.getTime())) {
                    return date;
                }
            }
        }
    }
    return value;
}
function getPlaceholder(index, dbType) {
    return dbType.includes('postgres') ? `$${index}` : '?';
}
function buildColumnTypeMap(columns) {
    return Object.fromEntries(columns.map((col) => [col.name, col.type]));
}
//# sourceMappingURL=sql-utils.js.map