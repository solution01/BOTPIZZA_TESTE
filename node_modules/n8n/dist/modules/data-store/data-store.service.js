"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataStoreService = void 0;
const api_types_1 = require("@n8n/api-types");
const backend_common_1 = require("@n8n/backend-common");
const di_1 = require("@n8n/di");
const data_store_column_repository_1 = require("./data-store-column.repository");
const data_store_rows_repository_1 = require("./data-store-rows.repository");
const data_store_repository_1 = require("./data-store.repository");
const data_store_column_not_found_error_1 = require("./errors/data-store-column-not-found.error");
const data_store_name_conflict_error_1 = require("./errors/data-store-name-conflict.error");
const data_store_not_found_error_1 = require("./errors/data-store-not-found.error");
const data_store_validation_error_1 = require("./errors/data-store-validation.error");
const sql_utils_1 = require("./utils/sql-utils");
let DataStoreService = class DataStoreService {
    constructor(dataStoreRepository, dataStoreColumnRepository, dataStoreRowsRepository, logger) {
        this.dataStoreRepository = dataStoreRepository;
        this.dataStoreColumnRepository = dataStoreColumnRepository;
        this.dataStoreRowsRepository = dataStoreRowsRepository;
        this.logger = logger;
        this.logger = this.logger.scoped('data-store');
    }
    async start() { }
    async shutdown() { }
    async createDataStore(projectId, dto) {
        await this.validateUniqueName(dto.name, projectId);
        return await this.dataStoreRepository.createDataStore(projectId, dto.name, dto.columns);
    }
    async updateDataStore(dataStoreId, projectId, dto) {
        await this.validateDataStoreExists(dataStoreId, projectId);
        await this.validateUniqueName(dto.name, projectId);
        await this.dataStoreRepository.update({ id: dataStoreId }, { name: dto.name });
        return true;
    }
    async deleteDataStoreByProjectId(projectId) {
        return await this.dataStoreRepository.deleteDataStoreByProjectId(projectId);
    }
    async deleteDataStoreAll() {
        return await this.dataStoreRepository.deleteDataStoreAll();
    }
    async deleteDataStore(dataStoreId, projectId) {
        await this.validateDataStoreExists(dataStoreId, projectId);
        await this.dataStoreRepository.deleteDataStore(dataStoreId);
        return true;
    }
    async addColumn(dataStoreId, projectId, dto) {
        await this.validateDataStoreExists(dataStoreId, projectId);
        return await this.dataStoreColumnRepository.addColumn(dataStoreId, dto);
    }
    async moveColumn(dataStoreId, projectId, columnId, dto) {
        await this.validateDataStoreExists(dataStoreId, projectId);
        const existingColumn = await this.validateColumnExists(dataStoreId, columnId);
        await this.dataStoreColumnRepository.moveColumn(dataStoreId, existingColumn, dto.targetIndex);
        return true;
    }
    async deleteColumn(dataStoreId, projectId, columnId) {
        await this.validateDataStoreExists(dataStoreId, projectId);
        const existingColumn = await this.validateColumnExists(dataStoreId, columnId);
        await this.dataStoreColumnRepository.deleteColumn(dataStoreId, existingColumn);
        return true;
    }
    async getManyAndCount(options) {
        return await this.dataStoreRepository.getManyAndCount(options);
    }
    async getManyRowsAndCount(dataStoreId, projectId, dto) {
        await this.validateDataStoreExists(dataStoreId, projectId);
        const columns = await this.dataStoreColumnRepository.getColumns(dataStoreId);
        const result = await this.dataStoreRowsRepository.getManyAndCount(dataStoreId, dto);
        return {
            count: result.count,
            data: (0, sql_utils_1.normalizeRows)(result.data, columns),
        };
    }
    async getColumns(dataStoreId, projectId) {
        await this.validateDataStoreExists(dataStoreId, projectId);
        return await this.dataStoreColumnRepository.getColumns(dataStoreId);
    }
    async insertRows(dataStoreId, projectId, rows, returnData = false) {
        await this.validateDataStoreExists(dataStoreId, projectId);
        await this.validateRows(dataStoreId, rows);
        const columns = await this.dataStoreColumnRepository.getColumns(dataStoreId);
        return await this.dataStoreRowsRepository.insertRows(dataStoreId, rows, columns, returnData);
    }
    async upsertRows(dataStoreId, projectId, dto) {
        await this.validateDataStoreExists(dataStoreId, projectId);
        await this.validateRows(dataStoreId, dto.rows);
        if (dto.rows.length === 0) {
            throw new data_store_validation_error_1.DataStoreValidationError('No rows provided for upsertRows');
        }
        const columns = await this.dataStoreColumnRepository.getColumns(dataStoreId);
        return await this.dataStoreRowsRepository.upsertRows(dataStoreId, dto, columns);
    }
    async updateRow(dataStoreId, projectId, dto) {
        await this.validateDataStoreExists(dataStoreId, projectId);
        const columns = await this.dataStoreColumnRepository.getColumns(dataStoreId);
        if (columns.length === 0) {
            throw new data_store_validation_error_1.DataStoreValidationError('No columns found for this data store or data store not found');
        }
        const { data, filter } = dto;
        if (!filter || Object.keys(filter).length === 0) {
            throw new data_store_validation_error_1.DataStoreValidationError('Filter columns must not be empty for updateRow');
        }
        if (!data || Object.keys(data).length === 0) {
            throw new data_store_validation_error_1.DataStoreValidationError('Data columns must not be empty for updateRow');
        }
        this.validateRowsWithColumns([filter], columns, true, true);
        this.validateRowsWithColumns([data], columns, true, false);
        await this.dataStoreRowsRepository.updateRow(dataStoreId, data, filter, columns);
        return true;
    }
    async deleteRows(dataStoreId, projectId, ids) {
        await this.validateDataStoreExists(dataStoreId, projectId);
        return await this.dataStoreRowsRepository.deleteRows(dataStoreId, ids);
    }
    validateRowsWithColumns(rows, columns, allowPartial = false, includeSystemColumns = false) {
        const allColumns = includeSystemColumns
            ? [{ name: 'id', type: 'number' }, ...columns]
            : columns;
        const columnNames = new Set(allColumns.map((x) => x.name));
        const columnTypeMap = new Map(allColumns.map((x) => [x.name, x.type]));
        for (const row of rows) {
            const keys = Object.keys(row);
            if (!allowPartial && columnNames.size !== keys.length) {
                throw new data_store_validation_error_1.DataStoreValidationError('mismatched key count');
            }
            for (const key of keys) {
                if (!columnNames.has(key)) {
                    throw new data_store_validation_error_1.DataStoreValidationError('unknown column name');
                }
                this.validateCell(row, key, columnTypeMap);
            }
        }
    }
    async validateRows(dataStoreId, rows, allowPartial = false, includeSystemColumns = false) {
        const columns = await this.dataStoreColumnRepository.getColumns(dataStoreId);
        this.validateRowsWithColumns(rows, columns, allowPartial, includeSystemColumns);
    }
    validateCell(row, key, columnTypeMap) {
        const cell = row[key];
        if (cell === null)
            return;
        const columnType = columnTypeMap.get(key);
        switch (columnType) {
            case 'boolean':
                if (typeof cell !== 'boolean') {
                    throw new data_store_validation_error_1.DataStoreValidationError(`value '${String(cell)}' does not match column type 'boolean'`);
                }
                break;
            case 'date':
                if (typeof cell === 'string') {
                    const validated = api_types_1.dateTimeSchema.safeParse(cell);
                    if (validated.success) {
                        row[key] = validated.data.toISOString();
                        break;
                    }
                }
                else if (cell instanceof Date) {
                    row[key] = cell.toISOString();
                    break;
                }
                throw new data_store_validation_error_1.DataStoreValidationError(`value '${cell}' does not match column type 'date'`);
            case 'string':
                if (typeof cell !== 'string') {
                    throw new data_store_validation_error_1.DataStoreValidationError(`value '${String(cell)}' does not match column type 'string'`);
                }
                break;
            case 'number':
                if (typeof cell !== 'number') {
                    throw new data_store_validation_error_1.DataStoreValidationError(`value '${String(cell)}' does not match column type 'number'`);
                }
                break;
        }
    }
    async validateDataStoreExists(dataStoreId, projectId) {
        const existingTable = await this.dataStoreRepository.findOneBy({
            id: dataStoreId,
            project: {
                id: projectId,
            },
        });
        if (!existingTable) {
            throw new data_store_not_found_error_1.DataStoreNotFoundError(dataStoreId);
        }
        return existingTable;
    }
    async validateColumnExists(dataStoreId, columnId) {
        const existingColumn = await this.dataStoreColumnRepository.findOneBy({
            id: columnId,
            dataStoreId,
        });
        if (existingColumn === null) {
            throw new data_store_column_not_found_error_1.DataStoreColumnNotFoundError(dataStoreId, columnId);
        }
        return existingColumn;
    }
    async validateUniqueName(name, projectId) {
        const hasNameClash = await this.dataStoreRepository.existsBy({
            name,
            projectId,
        });
        if (hasNameClash) {
            throw new data_store_name_conflict_error_1.DataStoreNameConflictError(name);
        }
    }
};
exports.DataStoreService = DataStoreService;
exports.DataStoreService = DataStoreService = __decorate([
    (0, di_1.Service)(),
    __metadata("design:paramtypes", [data_store_repository_1.DataStoreRepository,
        data_store_column_repository_1.DataStoreColumnRepository,
        data_store_rows_repository_1.DataStoreRowsRepository,
        backend_common_1.Logger])
], DataStoreService);
//# sourceMappingURL=data-store.service.js.map