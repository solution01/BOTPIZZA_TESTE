"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataStoreRowsRepository = void 0;
const config_1 = require("@n8n/config");
const db_1 = require("@n8n/db");
const di_1 = require("@n8n/di");
const typeorm_1 = require("@n8n/typeorm");
const n8n_workflow_1 = require("n8n-workflow");
const sql_utils_1 = require("./utils/sql-utils");
function getConditionAndParams(filter, index, dbType) {
    const paramName = `filter_${index}`;
    const column = `${(0, sql_utils_1.quoteIdentifier)('dataStore', dbType)}.${(0, sql_utils_1.quoteIdentifier)(filter.columnName, dbType)}`;
    switch (filter.condition) {
        case 'eq':
            return [`${column} = :${paramName}`, { [paramName]: filter.value }];
        case 'neq':
            return [`${column} != :${paramName}`, { [paramName]: filter.value }];
    }
}
let DataStoreRowsRepository = class DataStoreRowsRepository {
    constructor(dataSource, globalConfig) {
        this.dataSource = dataSource;
        this.globalConfig = globalConfig;
    }
    toTableName(dataStoreId) {
        const { tablePrefix } = this.globalConfig.database;
        return `${tablePrefix}data_store_user_${dataStoreId}`;
    }
    async insertRows(dataStoreId, rows, columns, returnData = false) {
        const inserted = [];
        const dbType = this.dataSource.options.type;
        const useReturning = dbType === 'postgres' || dbType === 'mariadb';
        const table = this.toTableName(dataStoreId);
        const columnNames = columns.map((c) => c.name);
        const escapedColumns = columns.map((c) => this.dataSource.driver.escape(c.name));
        const selectColumns = ['id', ...escapedColumns];
        for (const row of rows) {
            for (const column of columns) {
                row[column.name] = (0, sql_utils_1.normalizeValue)(row[column.name], column.type, dbType);
            }
            const query = this.dataSource
                .createQueryBuilder()
                .insert()
                .into(table, columnNames)
                .values(row);
            if (useReturning) {
                query.returning(returnData ? selectColumns.join(',') : 'id');
            }
            const result = await query.execute();
            if (useReturning) {
                const returned = (0, sql_utils_1.extractReturningData)(result.raw);
                inserted.push.apply(inserted, returned);
                continue;
            }
            const rowIds = (0, sql_utils_1.extractInsertedIds)(result.raw, dbType);
            if (rowIds.length === 0) {
                throw new n8n_workflow_1.UnexpectedError("Couldn't find the inserted row ID");
            }
            if (!returnData) {
                inserted.push(...rowIds.map((id) => ({ id })));
                continue;
            }
            const insertedRow = await this.dataSource
                .createQueryBuilder()
                .select(selectColumns)
                .from(table, 'dataStore')
                .where({ id: (0, typeorm_1.In)(rowIds) })
                .getRawOne();
            if (!insertedRow) {
                throw new n8n_workflow_1.UnexpectedError("Couldn't find the inserted row");
            }
            inserted.push(insertedRow);
        }
        return inserted;
    }
    async upsertRows(dataStoreId, dto, columns) {
        const { rows, matchFields } = dto;
        const { rowsToInsert, rowsToUpdate } = await this.fetchAndSplitRowsByExistence(dataStoreId, matchFields, rows);
        if (rowsToInsert.length > 0) {
            await this.insertRows(dataStoreId, rowsToInsert, columns);
        }
        if (rowsToUpdate.length > 0) {
            for (const row of rowsToUpdate) {
                const updateKeys = Object.keys(row).filter((key) => !matchFields.includes(key));
                if (updateKeys.length === 0) {
                    return true;
                }
                const setData = Object.fromEntries(updateKeys.map((key) => [key, row[key]]));
                const whereData = Object.fromEntries(matchFields.map((key) => [key, row[key]]));
                await this.updateRow(dataStoreId, setData, whereData, columns);
            }
        }
        return true;
    }
    async updateRow(dataStoreId, setData, whereData, columns) {
        const dbType = this.dataSource.options.type;
        const columnTypeMap = (0, sql_utils_1.buildColumnTypeMap)(columns);
        const queryBuilder = this.dataSource.createQueryBuilder().update(this.toTableName(dataStoreId));
        const setValues = {};
        for (const [key, value] of Object.entries(setData)) {
            setValues[key] = (0, sql_utils_1.normalizeValue)(value, columnTypeMap[key], dbType);
        }
        queryBuilder.set(setValues);
        const normalizedWhereData = {};
        for (const [field, value] of Object.entries(whereData)) {
            normalizedWhereData[field] = (0, sql_utils_1.normalizeValue)(value, columnTypeMap[field], dbType);
        }
        queryBuilder.where(normalizedWhereData);
        await queryBuilder.execute();
    }
    async deleteRows(dataStoreId, ids) {
        if (ids.length === 0) {
            return true;
        }
        const dbType = this.dataSource.options.type;
        const quotedTableName = (0, sql_utils_1.quoteIdentifier)(this.toTableName(dataStoreId), dbType);
        const placeholders = ids.map((_, index) => (0, sql_utils_1.getPlaceholder)(index + 1, dbType)).join(', ');
        const query = `DELETE FROM ${quotedTableName} WHERE id IN (${placeholders})`;
        await this.dataSource.query(query, ids);
        return true;
    }
    async createTableWithColumns(dataStoreId, columns, queryRunner) {
        const dslColumns = [new db_1.DslColumn('id').int.autoGenerate2.primary, ...(0, sql_utils_1.toDslColumns)(columns)];
        const createTable = new db_1.CreateTable(this.toTableName(dataStoreId), '', queryRunner);
        createTable.withColumns.apply(createTable, dslColumns);
        await createTable.execute(queryRunner);
    }
    async dropTable(dataStoreId, queryRunner) {
        await queryRunner.dropTable(this.toTableName(dataStoreId), true);
    }
    async addColumn(dataStoreId, column, queryRunner, dbType) {
        await queryRunner.query((0, sql_utils_1.addColumnQuery)(this.toTableName(dataStoreId), column, dbType));
    }
    async dropColumnFromTable(dataStoreId, columnName, queryRunner, dbType) {
        await queryRunner.query((0, sql_utils_1.deleteColumnQuery)(this.toTableName(dataStoreId), columnName, dbType));
    }
    async getManyAndCount(dataStoreId, dto) {
        const [countQuery, query] = this.getManyQuery(dataStoreId, dto);
        const data = await query.select('*').getRawMany();
        const countResult = await countQuery.select('COUNT(*) as count').getRawOne();
        const count = typeof countResult?.count === 'number' ? countResult.count : Number(countResult?.count) || 0;
        return { count: count ?? -1, data };
    }
    async getRowIds(dataStoreId, dto) {
        const [_, query] = this.getManyQuery(dataStoreId, dto);
        const result = await query.select('dataStore.id').getRawMany();
        return result;
    }
    getManyQuery(dataStoreId, dto) {
        const query = this.dataSource.createQueryBuilder();
        query.from(this.toTableName(dataStoreId), 'dataStore');
        this.applyFilters(query, dto);
        const countQuery = query.clone().select('COUNT(*)');
        this.applySorting(query, dto);
        this.applyPagination(query, dto);
        return [countQuery, query];
    }
    applyFilters(query, dto) {
        const filters = dto.filter?.filters ?? [];
        const filterType = dto.filter?.type ?? 'and';
        const dbType = this.dataSource.options.type;
        const conditionsAndParams = filters.map((filter, i) => getConditionAndParams(filter, i, dbType));
        for (const [condition, params] of conditionsAndParams) {
            if (filterType === 'or') {
                query.orWhere(condition, params);
            }
            else {
                query.andWhere(condition, params);
            }
        }
    }
    applySorting(query, dto) {
        if (!dto.sortBy) {
            return;
        }
        const [field, order] = dto.sortBy;
        this.applySortingByField(query, field, order);
    }
    applySortingByField(query, field, direction) {
        const dbType = this.dataSource.options.type;
        const quotedField = `${(0, sql_utils_1.quoteIdentifier)('dataStore', dbType)}.${(0, sql_utils_1.quoteIdentifier)(field, dbType)}`;
        query.orderBy(quotedField, direction);
    }
    applyPagination(query, dto) {
        query.skip(dto.skip);
        query.take(dto.take);
    }
    async fetchAndSplitRowsByExistence(dataStoreId, matchFields, rows) {
        const queryBuilder = this.dataSource
            .createQueryBuilder()
            .select(matchFields)
            .from(this.toTableName(dataStoreId), 'datastore');
        rows.forEach((row, index) => {
            const matchData = Object.fromEntries(matchFields.map((field) => [field, row[field]]));
            if (index === 0) {
                queryBuilder.where(matchData);
            }
            else {
                queryBuilder.orWhere(matchData);
            }
        });
        const existing = await queryBuilder.getRawMany();
        return (0, sql_utils_1.splitRowsByExistence)(existing, matchFields, rows);
    }
};
exports.DataStoreRowsRepository = DataStoreRowsRepository;
exports.DataStoreRowsRepository = DataStoreRowsRepository = __decorate([
    (0, di_1.Service)(),
    __metadata("design:paramtypes", [typeorm_1.DataSource,
        config_1.GlobalConfig])
], DataStoreRowsRepository);
//# sourceMappingURL=data-store-rows.repository.js.map