"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataStoreRowsRepository = void 0;
const config_1 = require("@n8n/config");
const db_1 = require("@n8n/db");
const di_1 = require("@n8n/di");
const typeorm_1 = require("@n8n/typeorm");
const n8n_workflow_1 = require("n8n-workflow");
const sql_utils_1 = require("./utils/sql-utils");
function getConditionAndParams(filter, index, dbType, columns) {
    const paramName = `filter_${index}`;
    const column = `${(0, sql_utils_1.quoteIdentifier)('dataStore', dbType)}.${(0, sql_utils_1.quoteIdentifier)(filter.columnName, dbType)}`;
    if (filter.value === null) {
        switch (filter.condition) {
            case 'eq':
                return [`${column} IS NULL`, {}];
            case 'neq':
                return [`${column} IS NOT NULL`, {}];
        }
    }
    const columnInfo = columns?.find((col) => col.name === filter.columnName);
    const value = columnInfo ? (0, sql_utils_1.normalizeValue)(filter.value, columnInfo?.type, dbType) : filter.value;
    const operators = {
        eq: '=',
        neq: '!=',
        gt: '>',
        gte: '>=',
        lt: '<',
        lte: '<=',
    };
    if (operators[filter.condition]) {
        return [`${column} ${operators[filter.condition]} :${paramName}`, { [paramName]: value }];
    }
    switch (filter.condition) {
        case 'like':
            if (['sqlite', 'sqlite-pooled'].includes(dbType)) {
                const globValue = (0, sql_utils_1.toSqliteGlobFromPercent)(value);
                return [`${column} GLOB :${paramName}`, { [paramName]: globValue }];
            }
            if (['mysql', 'mariadb'].includes(dbType)) {
                const escapedValue = (0, sql_utils_1.escapeLikeSpecials)(value);
                return [`${column} LIKE BINARY :${paramName} ESCAPE '\\\\'`, { [paramName]: escapedValue }];
            }
            if (dbType === 'postgres') {
                const escapedValue = (0, sql_utils_1.escapeLikeSpecials)(value);
                return [`${column} LIKE :${paramName} ESCAPE '\\'`, { [paramName]: escapedValue }];
            }
            return [`${column} LIKE :${paramName}`, { [paramName]: value }];
        case 'ilike':
            if (['sqlite', 'sqlite-pooled'].includes(dbType)) {
                const escapedValue = (0, sql_utils_1.escapeLikeSpecials)(value);
                return [
                    `UPPER(${column}) LIKE UPPER(:${paramName}) ESCAPE '\\'`,
                    { [paramName]: escapedValue },
                ];
            }
            if (['mysql', 'mariadb'].includes(dbType)) {
                const escapedValue = (0, sql_utils_1.escapeLikeSpecials)(value);
                return [
                    `UPPER(${column}) LIKE UPPER(:${paramName}) ESCAPE '\\\\'`,
                    { [paramName]: escapedValue },
                ];
            }
            if (dbType === 'postgres') {
                const escapedValue = (0, sql_utils_1.escapeLikeSpecials)(value);
                return [`${column} ILIKE :${paramName} ESCAPE '\\'`, { [paramName]: escapedValue }];
            }
            return [`UPPER(${column}) LIKE UPPER(:${paramName})`, { [paramName]: value }];
    }
    throw new Error(`Unsupported filter condition: ${filter.condition}`);
}
let DataStoreRowsRepository = class DataStoreRowsRepository {
    constructor(dataSource, globalConfig) {
        this.dataSource = dataSource;
        this.globalConfig = globalConfig;
    }
    toTableName(dataStoreId) {
        const { tablePrefix } = this.globalConfig.database;
        return `${tablePrefix}data_table_user_${dataStoreId}`;
    }
    async insertRows(dataStoreId, rows, columns, returnData) {
        const inserted = [];
        const dbType = this.dataSource.options.type;
        const useReturning = dbType === 'postgres' || dbType === 'mariadb';
        const table = this.toTableName(dataStoreId);
        const escapedColumns = columns.map((c) => this.dataSource.driver.escape(c.name));
        const escapedSystemColumns = n8n_workflow_1.DATA_TABLE_SYSTEM_COLUMNS.map((x) => this.dataSource.driver.escape(x));
        const selectColumns = [...escapedSystemColumns, ...escapedColumns];
        for (const row of rows) {
            const completeRow = { ...row };
            for (const column of columns) {
                if (!(column.name in completeRow)) {
                    completeRow[column.name] = null;
                }
                completeRow[column.name] = (0, sql_utils_1.normalizeValue)(completeRow[column.name], column.type, dbType);
            }
            const query = this.dataSource.createQueryBuilder().insert().into(table).values(completeRow);
            if (useReturning) {
                query.returning(returnData ? selectColumns.join(',') : 'id');
            }
            const result = await query.execute();
            if (useReturning) {
                const returned = returnData
                    ? (0, sql_utils_1.normalizeRows)((0, sql_utils_1.extractReturningData)(result.raw), columns)
                    : (0, sql_utils_1.extractInsertedIds)(result.raw, dbType).map((id) => ({ id }));
                inserted.push.apply(inserted, returned);
                continue;
            }
            const ids = (0, sql_utils_1.extractInsertedIds)(result.raw, dbType);
            if (ids.length === 0) {
                throw new n8n_workflow_1.UnexpectedError("Couldn't find the inserted row ID");
            }
            if (!returnData) {
                inserted.push(...ids.map((id) => ({ id })));
                continue;
            }
            const insertedRows = await this.getManyByIds(dataStoreId, ids, columns);
            inserted.push(...insertedRows);
        }
        return inserted;
    }
    async updateRow(dataStoreId, setData, whereData, columns, returnData = false) {
        const dbType = this.dataSource.options.type;
        const useReturning = dbType === 'postgres';
        const table = this.toTableName(dataStoreId);
        const escapedColumns = columns.map((c) => this.dataSource.driver.escape(c.name));
        const escapedSystemColumns = n8n_workflow_1.DATA_TABLE_SYSTEM_COLUMNS.map((x) => this.dataSource.driver.escape(x));
        const selectColumns = [...escapedSystemColumns, ...escapedColumns];
        for (const column of columns) {
            if (column.name in setData) {
                setData[column.name] = (0, sql_utils_1.normalizeValue)(setData[column.name], column.type, dbType);
            }
            if (column.name in whereData) {
                whereData[column.name] = (0, sql_utils_1.normalizeValue)(whereData[column.name], column.type, dbType);
            }
        }
        let affectedRows = [];
        if (!useReturning && returnData) {
            affectedRows = await this.dataSource
                .createQueryBuilder()
                .select('id')
                .from(table, 'dataStore')
                .where(whereData)
                .getRawMany();
        }
        setData.updatedAt = (0, sql_utils_1.normalizeValue)(new Date(), 'date', dbType);
        const query = this.dataSource.createQueryBuilder().update(table).set(setData).where(whereData);
        if (useReturning && returnData) {
            query.returning(selectColumns.join(','));
        }
        const result = await query.execute();
        if (!returnData) {
            return true;
        }
        if (useReturning) {
            return (0, sql_utils_1.normalizeRows)((0, sql_utils_1.extractReturningData)(result.raw), columns);
        }
        const ids = affectedRows.map((row) => row.id);
        return await this.getManyByIds(dataStoreId, ids, columns);
    }
    async upsertRows(dataStoreId, matchFields, rows, columns, returnData) {
        returnData = returnData ?? false;
        const { rowsToInsert, rowsToUpdate } = await this.fetchAndSplitRowsByExistence(dataStoreId, matchFields, rows);
        const output = [];
        if (rowsToInsert.length > 0) {
            const result = await this.insertRows(dataStoreId, rowsToInsert, columns, returnData);
            if (returnData) {
                output.push.apply(output, result);
            }
        }
        if (rowsToUpdate.length > 0) {
            for (const row of rowsToUpdate) {
                const updateKeys = Object.keys(row).filter((key) => !matchFields.includes(key));
                if (updateKeys.length === 0) {
                    return true;
                }
                const setData = Object.fromEntries(updateKeys.map((key) => [key, row[key]]));
                const whereData = Object.fromEntries(matchFields.map((key) => [key, row[key]]));
                const result = await this.updateRow(dataStoreId, setData, whereData, columns, returnData);
                if (returnData) {
                    output.push.apply(output, result);
                }
            }
        }
        return returnData ? output : true;
    }
    async deleteRows(dataStoreId, ids) {
        if (ids.length === 0) {
            return true;
        }
        const table = this.toTableName(dataStoreId);
        await this.dataSource
            .createQueryBuilder()
            .delete()
            .from(table, 'dataStore')
            .where({ id: (0, typeorm_1.In)(ids) })
            .execute();
        return true;
    }
    async createTableWithColumns(dataStoreId, columns, queryRunner) {
        const dslColumns = [new db_1.DslColumn('id').int.autoGenerate2.primary, ...(0, sql_utils_1.toDslColumns)(columns)];
        const createTable = new db_1.CreateTable(this.toTableName(dataStoreId), '', queryRunner).withColumns(...dslColumns).withTimestamps;
        await createTable.execute(queryRunner);
    }
    async dropTable(dataStoreId, queryRunner) {
        await queryRunner.dropTable(this.toTableName(dataStoreId), true);
    }
    async addColumn(dataStoreId, column, queryRunner, dbType) {
        await queryRunner.query((0, sql_utils_1.addColumnQuery)(this.toTableName(dataStoreId), column, dbType));
    }
    async dropColumnFromTable(dataStoreId, columnName, queryRunner, dbType) {
        await queryRunner.query((0, sql_utils_1.deleteColumnQuery)(this.toTableName(dataStoreId), columnName, dbType));
    }
    async getManyAndCount(dataStoreId, dto, columns) {
        const [countQuery, query] = this.getManyQuery(dataStoreId, dto, columns);
        const data = await query.select('*').getRawMany();
        const countResult = await countQuery.select('COUNT(*) as count').getRawOne();
        const count = typeof countResult?.count === 'number' ? countResult.count : Number(countResult?.count) || 0;
        return { count: count ?? -1, data };
    }
    async getManyByIds(dataStoreId, ids, columns) {
        const table = this.toTableName(dataStoreId);
        const escapedColumns = columns.map((c) => this.dataSource.driver.escape(c.name));
        const escapedSystemColumns = n8n_workflow_1.DATA_TABLE_SYSTEM_COLUMNS.map((x) => this.dataSource.driver.escape(x));
        const selectColumns = [...escapedSystemColumns, ...escapedColumns];
        if (ids.length === 0) {
            return [];
        }
        const updatedRows = await this.dataSource
            .createQueryBuilder()
            .select(selectColumns)
            .from(table, 'dataStore')
            .where({ id: (0, typeorm_1.In)(ids) })
            .getRawMany();
        return (0, sql_utils_1.normalizeRows)(updatedRows, columns);
    }
    async getRowIds(dataStoreId, dto) {
        const [_, query] = this.getManyQuery(dataStoreId, dto);
        const result = await query.select('dataStore.id').getRawMany();
        return result;
    }
    getManyQuery(dataStoreId, dto, columns) {
        const query = this.dataSource.createQueryBuilder();
        query.from(this.toTableName(dataStoreId), 'dataStore');
        this.applyFilters(query, dto, columns);
        const countQuery = query.clone().select('COUNT(*)');
        this.applySorting(query, dto);
        this.applyPagination(query, dto);
        return [countQuery, query];
    }
    applyFilters(query, dto, columns) {
        const filters = dto.filter?.filters ?? [];
        const filterType = dto.filter?.type ?? 'and';
        const dbType = this.dataSource.options.type;
        const conditionsAndParams = filters.map((filter, i) => getConditionAndParams(filter, i, dbType, columns));
        for (const [condition, params] of conditionsAndParams) {
            if (filterType === 'or') {
                query.orWhere(condition, params);
            }
            else {
                query.andWhere(condition, params);
            }
        }
    }
    applySorting(query, dto) {
        if (!dto.sortBy) {
            return;
        }
        const [field, order] = dto.sortBy;
        this.applySortingByField(query, field, order);
    }
    applySortingByField(query, field, direction) {
        const dbType = this.dataSource.options.type;
        const quotedField = `${(0, sql_utils_1.quoteIdentifier)('dataStore', dbType)}.${(0, sql_utils_1.quoteIdentifier)(field, dbType)}`;
        query.orderBy(quotedField, direction);
    }
    applyPagination(query, dto) {
        query.skip(dto.skip);
        query.take(dto.take);
    }
    async fetchAndSplitRowsByExistence(dataStoreId, matchFields, rows) {
        const queryBuilder = this.dataSource
            .createQueryBuilder()
            .select(matchFields)
            .from(this.toTableName(dataStoreId), 'datastore');
        rows.forEach((row, index) => {
            const matchData = Object.fromEntries(matchFields.map((field) => [field, row[field]]));
            if (index === 0) {
                queryBuilder.where(matchData);
            }
            else {
                queryBuilder.orWhere(matchData);
            }
        });
        const existing = await queryBuilder.getRawMany();
        return (0, sql_utils_1.splitRowsByExistence)(existing, matchFields, rows);
    }
};
exports.DataStoreRowsRepository = DataStoreRowsRepository;
exports.DataStoreRowsRepository = DataStoreRowsRepository = __decorate([
    (0, di_1.Service)(),
    __metadata("design:paramtypes", [typeorm_1.DataSource,
        config_1.GlobalConfig])
], DataStoreRowsRepository);
//# sourceMappingURL=data-store-rows.repository.js.map